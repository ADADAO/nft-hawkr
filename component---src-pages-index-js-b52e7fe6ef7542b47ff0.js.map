{"version":3,"file":"component---src-pages-index-js-b52e7fe6ef7542b47ff0.js","mappings":"2HAAA,IAEIA,EAAU,CACVC,WAHa,2CAMjB,O,+HCNMC,EAAAA,WAAAA,SAAAA,KAaH,OAbGA,EAAAA,UACEC,KAAAA,WAAAA,IAAAA,GAAAA,EAAAA,EAAAA,GAAAA,IAAAA,MAAN,kFACMC,KAAKC,MADX,iEAKqB,sDALrB,OAKED,KAAKC,MALP,yGAAMF,IAAN,6BAUA,WACE,OAAOC,KAAKC,UACb,EAbGH,GAgBN,IAAmBA,E,gBCVc,oBAAXI,QAA0BA,OAAOC,O,QA6zBvD,ICxzBMC,EAAa,CACjBC,MAAO,UACPC,QAAS,GACTC,WAAY,4CAERC,EAAgB,CACpBC,UAAW,EACXC,aAAc,GACdC,SAAU,KAENC,EAAsB,CAC1BP,MAAO,WAEHQ,EAAkB,CACtBH,aAAc,IAEVI,EAAa,CACjBT,MAAO,UACPC,QAAS,EACTS,gBAAiB,UACjBC,SAAU,UACVC,aAAc,GAEVC,EAAa,CACjBR,aAAc,GACdS,YAAa,GAETC,EAAiB,CACrBC,WAAY,IACZL,SAAU,GACVL,SAAU,IACVD,aAAc,IAGVY,EAAY,CAChBjB,MAAO,UACPgB,WAAY,OACZL,SAAU,GACVO,cAAe,MAGXC,EAAY,iBACbF,EADa,CAEhBG,cAAe,OACff,aAAc,KAGVgB,EAAmB,CACvBrB,MAAO,UACPW,SAAU,GACVP,UAAW,GACXC,aAAc,EACdiB,WAAY,MAGRC,EACE,gBADFA,EAEC,iCAIDC,EAAa,CACjBxB,MAAO,OACPU,gBAAiB,UACjBe,OAAQ,oBACRd,SAAU,GACVK,WAAY,OACZU,cAAe,EACfd,aAAc,EACdX,QAAS,UACT0B,QAAS,eACTC,SAAU,WACVC,KAAM,EACNC,WAAY,GACZR,WAAY,GAIRS,EAAQ,CACZ,CACEC,KAAM,WACNC,IAAK,0CACLC,YACE,kIACFlC,MAAO,WAET,CACEgC,KAAM,gBACNC,IAAK,wCACLC,YACE,2HACFlC,MAAO,WAET,CACEgC,KAAM,mBACNC,IAAK,2CACLC,YACE,+HACFlC,MAAO,WAET,CACEgC,KAAM,oBACNC,IAAK,4CACLC,YACE,0HACFlC,MAAO,WAET,CACEgC,KAAM,iBACNC,IAAK,mCACLC,YACE,8HACFlC,MAAO,WAET,CACEgC,KAAM,iBACNC,IAAK,iCACLE,OAAO,EACPD,YACE,+HACFlC,MAAO,YAmFX,EAvDkB,WAChB,OACE,wBAAMoC,MAAOrC,GACX,0CACA,sBAAIqC,MAAOjC,GAAX,kBAEE,2BACA,wBAAMiC,MAAO7B,GAAb,mCACA,wBAAM8B,KAAK,MAAM,aAAW,uBAA5B,WAIF,qBAAGD,MAAO5B,GAAV,QACO,wBAAM4B,MAAO3B,GAAb,sBADP,yCAEuB,IACrB,wBAAM4B,KAAK,MAAM,aAAW,2BAA5B,OAIF,sBAAID,MAAOvB,GACT,sBAAIuB,MAAOjB,GACT,qBACEiB,MAAOnB,EACPqB,KAASf,EAAL,0EAEHA,IAGJQ,EAAMQ,KAAI,SAAAC,GAAI,OACb,sBAAIC,IAAKD,EAAKP,IAAKG,MAAK,iBAAOrB,EAAP,CAAuBf,MAAOwC,EAAKxC,SACzD,4BACE,qBACEoC,MAAOnB,EACPqB,KAASE,EAAKP,IAAV,0EAEHO,EAAKR,MAEPQ,EAAKL,OACJ,wBAAMC,MAAOZ,EAAY,aAAW,aAApC,QAIF,qBAAGY,MAAOf,GAAmBmB,EAAKN,mBAK1C,uBACEQ,IAAI,gBACJC,IAAI","sources":["webpack://yoctodao-interface/./secrets.js","webpack://yoctodao-interface/./src/cardano/market/loader.js","webpack://yoctodao-interface/./src/cardano/market/coinSelection.js","webpack://yoctodao-interface/./src/pages/index.js"],"sourcesContent":["const PROJECT_ID=\"mainnetsm9KvzwMM6S35W9yLyc1f8sn9hzHuAnQ\"\n\nlet secrets = {\n    PROJECT_ID: PROJECT_ID\n}\n\nexport default secrets;","class Loader {\n  async load() {\n    if (this._wasm) return;\n    /**\n     * @private\n     */\n    this._wasm = await import(\n      \"./custom_modules/@emurgo/cardano-serialization-lib-browser/cardano_serialization_lib\"\n    );\n  }\n\n  get Cardano() {\n    return this._wasm;\n  }\n}\n\nexport default new Loader();\n","import {\n  TransactionUnspentOutput,\n  TransactionOutputs,\n  Value,\n} from \"./custom_modules/@emurgo/cardano-serialization-lib-browser/cardano_serialization_lib\";\nimport Loader from \"./loader\";\nconst BigInt = typeof window !== \"undefined\" && window.BigInt;\n\n/**\n * BerryPool implementation of the __Random-Improve__ coin selection algorithm.\n *\n * = Overview\n *\n * The __Random-Improve__ coin selection algorithm works in __two phases__, by\n * /first/ selecting UTxO entries /at random/ to pay for each of the given\n * outputs, and /then/ attempting to /improve/ upon each of the selections.\n *\n * === Phase 1: Random Selection\n *\n * __In this phase, the algorithm randomly selects a minimal set of UTxO__\n * __entries to pay for each of the given outputs.__\n *\n * During this phase, the algorithm:\n *\n *   *  processes outputs in /descending order of coin value/.\n *\n *   *  maintains a /remaining UTxO set/, initially equal to the given\n *      /UTxO set/ parameter.\n *\n *   *  based on every output nature, generate a /native token UTxO subset/\n *      to narrow down to useful UTxO\n *\n *   *  maintains an /accumulated coin selection/, which is initially /empty/.\n *\n * For each output of value __/v/__, the algorithm /randomly/ selects entries\n * from the /remaining UTxO set/, until the total value of selected entries is\n * greater than or equal to __/v/__. The selected entries are then associated\n * with that output, and removed from the /remaining UTxO set/.\n *\n * This phase ends when every output has been associated with a selection of\n * UTxO entries.\n *\n * However, if the remaining UTxO set is completely exhausted before all\n * outputs can be processed, the algorithm terminates with an error.\n *\n * === Phase 2: Improvement\n *\n * __In this phase, the algorithm attempts to improve upon each of the UTxO__\n * __selections made in the previous phase, by conservatively expanding the__\n * __selection made for each output.__\n *\n * During this phase, the algorithm:\n *\n *   *  processes outputs in /ascending order of coin value/.\n *\n *   *  continues to maintain the /remaining UTxO set/ produced by the previous\n *      phase.\n *\n *   *  maintains an /accumulated coin selection/, initiated from previous phase.\n *\n * For each output of value __/v/__, the algorithm:\n *\n *  1.  __Calculates a /target range/__ for the total value of inputs used to\n *      pay for that output, defined by the triplet:\n *\n *      (/minimum/, /ideal/, /maximum/) = (/v/, /2v/, /3v/)\n *\n *  2.  __Attempts to /improve/ upon the /existing UTxO selection/__ for that\n *      output, by repeatedly selecting additional entries at random from the\n *      /remaining UTxO set/, stopping when the selection can be improved upon\n *      no further.\n *\n *      A selection with value /v1/ is considered to be an /improvement/ over a\n *      selection with value /v0/ if __all__ of the following conditions are\n *      satisfied:\n *\n *       * __Condition 1__: we have moved closer to the /ideal/ value:\n *\n *             abs (/ideal/ − /v1/) < abs (/ideal/ − /v0/)\n *\n *       * __Condition 2__: we have not exceeded the /maximum/ value:\n *\n *             /v1/ ≤ /maximum/\n *\n *       * __Condition 3__: when counting cumulatively across all outputs\n *       considered so far, we have not selected more than the /maximum/ number\n *       of UTxO entries specified by 'limit'.\n *\n *  3.  __Creates a /change value/__ for the output, equal to the total value\n *      of the /final UTxO selection/ for that output minus the value /v/ of\n *      that output.\n *\n *  4.  __Updates the /accumulated coin selection/__:\n *\n *       * Adds the /output/ to 'outputs'.\n *       * Adds the /improved UTxO selection/ to 'inputs'.\n *       * Adds the /change value/ to 'change'.\n *\n * This phase ends when every output has been processed, __or__ when the\n * /remaining UTxO set/ has been exhausted, whichever occurs sooner.\n *\n * = Termination\n *\n * When both phases are complete, the algorithm terminates.\n *\n * The /accumulated coin selection/ and /remaining UTxO set/ are returned to\n * the caller.\n *\n * === Failure Modes\n *\n * The algorithm terminates with an __error__ if:\n *\n *  1.  The /total value/ of the initial UTxO set (the amount of money\n *      /available/) is /less than/ the total value of the output list (the\n *      amount of money /required/).\n *\n *      See: __'InputsExhaustedError'__.\n *\n *  2.  The /number/ of UTxO entries needed to pay for the requested outputs\n *      would /exceed/ the upper limit specified by 'limit'.\n *\n *      See: __'InputLimitExceededError'__.\n *\n * == Motivating Principles\n *\n * There are several motivating principles behind the design of the algorithm.\n *\n * === Principle 1: Dust Management\n *\n * The probability that random selection will choose dust entries from a UTxO\n * set increases with the proportion of dust in the set.\n *\n * Therefore, for a UTxO set with a large amount of dust, there's a high\n * probability that a random subset will include a large amount of dust.\n *\n * === Principle 2: Change Management\n *\n * Ideally, coin selection algorithms should, over time, create a UTxO set that\n * has /useful/ outputs: outputs that will allow us to process future payments\n * with a minimum number of inputs.\n *\n * If for each payment request of value __/v/__ we create a change output of\n * /roughly/ the same value __/v/__, then we will end up with a distribution of\n * change values that matches the typical value distribution of payment\n * requests.\n *\n * === Principle 3: Performance Management\n *\n * Searching the UTxO set for additional entries to improve our change outputs\n * is /only/ useful if the UTxO set contains entries that are sufficiently\n * small enough. But it is precisely when the UTxO set contains many small\n * entries that it is less likely for a randomly-chosen UTxO entry to push the\n * total above the upper bound.\n */\n\n/**\n * @typedef {Value[]} AmountList - List of 'Value' object\n */\n\n/**\n * @typedef {TransactionUnspentOutput[]} UTxOList - List of UTxO\n */\n\n/**\n * @typedef {Object} UTxOSelection - Coin Selection algorithm core object\n * @property {UTxOList} selection - Accumulated UTxO set.\n * @property {UTxOList} remaining - Remaining UTxO set.\n * @property {UTxOList} subset - Remaining UTxO set.\n * @property {Value} amount - UTxO amount of each requested token\n */\n\n/**\n * @typedef {Object} ImproveRange - ImproveRange\n * @property {Value} ideal - Requested amount * 2\n * @property {Value} maximum - Requested amount * 3\n */\n\n/**\n * @typedef {Object} SelectionResult - Coin Selection algorithm return\n * @property {UTxOList} input - Accumulated UTxO set.\n * @property {OutputList} output - Requested outputs.\n * @property {UTxOList} remaining - Remaining UTxO set.\n * @property {Value} amount - UTxO amount of each requested token\n * @property {Value} change - Accumulated change amount.\n */\n\n/**\n * @typedef {Object} ProtocolParameters\n * @property {int} minUTxO\n * @property {int} minFeeA\n * @property {int} minFeeB\n * @property {int} maxTxSize\n */\n\n/**\n * @type {ProtocolParameters}\n */\nlet protocolParameters = null;\n\n/**\n * CoinSelection Module.\n * @module src/lib/CoinSelection\n */\nconst CoinSelection = {\n  /**\n   * Set protocol parameters required by the algorithm\n   * @param {string} minUTxO\n   * @param {string} minFeeA\n   * @param {string} minFeeB\n   * @param {string} maxTxSize\n   */\n  setProtocolParameters: (minUTxO, minFeeA, minFeeB, maxTxSize) => {\n    protocolParameters = {\n      minUTxO: minUTxO,\n      minFeeA: minFeeA,\n      minFeeB: minFeeB,\n      maxTxSize: maxTxSize,\n    };\n  },\n  /**\n   * Random-Improve coin selection algorithm\n   * @param {UTxOList} inputs - The set of inputs available for selection.\n   * @param {TransactionOutputs} outputs - The set of outputs requested for payment.\n   * @param {int} limit - A limit on the number of inputs that can be selected.\n   * @param {UTxOList} [preset=[]]] - The pre-selection of inputs that will be added.\n   * @return {SelectionResult} - Coin Selection algorithm return\n   */\n  randomImprove: (inputs, outputs, limit, preset = []) => {\n    if (!protocolParameters)\n      throw new Error(\n        \"Protocol parameters not set. Use setProtocolParameters().\"\n      );\n\n    const _minUTxOValue =\n      BigInt(outputs.len()) * BigInt(protocolParameters.minUTxO);\n\n    let amount = Loader.Cardano.Value.new(Loader.Cardano.BigNum.from_str(\"0\"));\n\n    for (let i = 0; i < preset.length; i++) {\n      amount = addAmounts(preset[i].output().amount(), amount);\n    }\n\n    /** @type {UTxOSelection} */\n    let utxoSelection = {\n      selection: [...preset], // Shallow copy\n      remaining: [...inputs], // Shallow copy\n      subset: [],\n      amount: amount,\n    };\n\n    let mergedOutputsAmounts = mergeOutputsAmounts(outputs);\n\n    // Explode amount in an array of unique asset amount for comparison's sake\n    let splitOutputsAmounts = splitAmounts(mergedOutputsAmounts);\n\n    // Phase 1: Select enough input\n    for (let i = 0; i < splitOutputsAmounts.length; i++) {\n      createSubSet(utxoSelection, splitOutputsAmounts[i]); // Narrow down for NatToken UTxO\n\n      utxoSelection = select(\n        utxoSelection,\n        splitOutputsAmounts[i],\n        limit,\n        _minUTxOValue\n      );\n    }\n\n    // Phase 2: Improve\n    splitOutputsAmounts = sortAmountList(splitOutputsAmounts);\n\n    for (let i = 0; i < splitOutputsAmounts.length; i++) {\n      createSubSet(utxoSelection, splitOutputsAmounts[i]); // Narrow down for NatToken UTxO\n\n      let range = {};\n      range.ideal = Loader.Cardano.Value.new(\n        Loader.Cardano.BigNum.from_str(\"0\")\n      )\n        .checked_add(splitOutputsAmounts[i])\n        .checked_add(splitOutputsAmounts[i]);\n      range.maximum = Loader.Cardano.Value.new(\n        Loader.Cardano.BigNum.from_str(\"0\")\n      )\n        .checked_add(range.ideal)\n        .checked_add(splitOutputsAmounts[i]);\n\n      improve(\n        utxoSelection,\n        splitOutputsAmounts[i],\n        limit - utxoSelection.selection.length,\n        range\n      );\n    }\n\n    // Insure change hold enough Ada to cover included native assets and fees\n    if (utxoSelection.remaining.length > 0) {\n      const change = utxoSelection.amount.checked_sub(mergedOutputsAmounts);\n\n      let minAmount = Loader.Cardano.Value.new(\n        Loader.Cardano.min_ada_required(\n          change,\n          Loader.Cardano.BigNum.from_str(protocolParameters.minUTxO)\n        )\n      );\n\n      let maxFee =\n        BigInt(protocolParameters.minFeeA) *\n          BigInt(protocolParameters.maxTxSize) +\n        BigInt(protocolParameters.minFeeB);\n\n      maxFee = Loader.Cardano.Value.new(\n        Loader.Cardano.BigNum.from_str(maxFee.toString())\n      );\n\n      minAmount = minAmount.checked_add(maxFee);\n\n      if (compare(change, minAmount) < 0) {\n        // Not enough, add missing amount and run select one last time\n        const minAda = minAmount\n          .checked_sub(Loader.Cardano.Value.new(change.coin()))\n          .checked_add(Loader.Cardano.Value.new(utxoSelection.amount.coin()));\n\n        createSubSet(utxoSelection, minAda);\n        utxoSelection = select(utxoSelection, minAda, limit, _minUTxOValue);\n      }\n    }\n\n    return {\n      input: utxoSelection.selection,\n      output: outputs,\n      remaining: utxoSelection.remaining,\n      amount: utxoSelection.amount,\n      change: utxoSelection.amount.checked_sub(mergedOutputsAmounts),\n    };\n  },\n};\n\n/**\n * Use randomSelect & descSelect algorithm to select enough UTxO to fulfill requested outputs\n * @param {UTxOSelection} utxoSelection - The set of selected/available inputs.\n * @param {Value} outputAmount - Single compiled output qty requested for payment.\n * @param {int} limit - A limit on the number of inputs that can be selected.\n * @param {int} minUTxOValue - Network protocol 'minUTxOValue' current value.\n * @throws INPUT_LIMIT_EXCEEDED if the number of randomly picked inputs exceed 'limit' parameter.\n * @throws INPUTS_EXHAUSTED if all UTxO doesn't hold enough funds to pay for output.\n * @throws MIN_UTXO_ERROR if lovelace change is under 'minUTxOValue' parameter.\n * @return {UTxOSelection} - Successful random utxo selection.\n */\nfunction select(utxoSelection, outputAmount, limit, minUTxOValue) {\n  try {\n    utxoSelection = randomSelect(\n      cloneUTxOSelection(utxoSelection), // Deep copy in case of fallback needed\n      outputAmount,\n      limit - utxoSelection.selection.length,\n      minUTxOValue\n    );\n  } catch (e) {\n    if (e.message === \"INPUT_LIMIT_EXCEEDED\") {\n      // Limit reached : Fallback on DescOrdAlgo\n      utxoSelection = descSelect(\n        utxoSelection,\n        outputAmount,\n        limit - utxoSelection.selection.length,\n        minUTxOValue\n      );\n    } else {\n      throw e;\n    }\n  }\n\n  return utxoSelection;\n}\n\n/**\n * Randomly select enough UTxO to fulfill requested outputs\n * @param {UTxOSelection} utxoSelection - The set of selected/available inputs.\n * @param {Value} outputAmount - Single compiled output qty requested for payment.\n * @param {int} limit - A limit on the number of inputs that can be selected.\n * @param {int} minUTxOValue - Network protocol 'minUTxOValue' current value.\n * @throws INPUT_LIMIT_EXCEEDED if the number of randomly picked inputs exceed 'limit' parameter.\n * @throws INPUTS_EXHAUSTED if all UTxO doesn't hold enough funds to pay for output.\n * @throws MIN_UTXO_ERROR if lovelace change is under 'minUTxOValue' parameter.\n * @return {UTxOSelection} - Successful random utxo selection.\n */\nfunction randomSelect(utxoSelection, outputAmount, limit, minUTxOValue) {\n  let nbFreeUTxO = utxoSelection.subset.length;\n  // If quantity is met, return subset into remaining list and exit\n  if (\n    isQtyFulfilled(outputAmount, utxoSelection.amount, minUTxOValue, nbFreeUTxO)\n  ) {\n    utxoSelection.remaining = [\n      ...utxoSelection.remaining,\n      ...utxoSelection.subset,\n    ];\n    utxoSelection.subset = [];\n    return utxoSelection;\n  }\n\n  if (limit <= 0) {\n    throw new Error(\"INPUT_LIMIT_EXCEEDED\");\n  }\n\n  if (nbFreeUTxO <= 0) {\n    if (isQtyFulfilled(outputAmount, utxoSelection.amount, 0, 0)) {\n      throw new Error(\"MIN_UTXO_ERROR\");\n    }\n    throw new Error(\"INPUTS_EXHAUSTED\");\n  }\n\n  /** @type {TransactionUnspentOutput} utxo */\n  let utxo = utxoSelection.subset\n    .splice(Math.floor(Math.random() * nbFreeUTxO), 1)\n    .pop();\n\n  utxoSelection.selection.push(utxo);\n  utxoSelection.amount = addAmounts(\n    utxo.output().amount(),\n    utxoSelection.amount\n  );\n\n  return randomSelect(utxoSelection, outputAmount, limit - 1, minUTxOValue);\n}\n\n/**\n * Select enough UTxO in DESC order to fulfill requested outputs\n * @param {UTxOSelection} utxoSelection - The set of selected/available inputs.\n * @param {Value} outputAmount - Single compiled output qty requested for payment.\n * @param {int} limit - A limit on the number of inputs that can be selected.\n * @param {int} minUTxOValue - Network protocol 'minUTxOValue' current value.\n * @throws INPUT_LIMIT_EXCEEDED if the number of randomly picked inputs exceed 'limit' parameter.\n * @throws INPUTS_EXHAUSTED if all UTxO doesn't hold enough funds to pay for output.\n * @throws MIN_UTXO_ERROR if lovelace change is under 'minUTxOValue' parameter.\n * @return {UTxOSelection} - Successful random utxo selection.\n */\nfunction descSelect(utxoSelection, outputAmount, limit, minUTxOValue) {\n  // Sort UTxO subset in DESC order for required Output unit type\n  utxoSelection.subset = utxoSelection.subset.sort((a, b) => {\n    return Number(\n      searchAmountValue(outputAmount, b.output().amount()) -\n        searchAmountValue(outputAmount, a.output().amount())\n    );\n  });\n\n  do {\n    if (limit <= 0) {\n      throw new Error(\"INPUT_LIMIT_EXCEEDED\");\n    }\n\n    if (utxoSelection.subset.length <= 0) {\n      if (isQtyFulfilled(outputAmount, utxoSelection.amount, 0, 0)) {\n        throw new Error(\"MIN_UTXO_ERROR\");\n      }\n      throw new Error(\"INPUTS_EXHAUSTED\");\n    }\n\n    /** @type {TransactionUnspentOutput} utxo */\n    let utxo = utxoSelection.subset.splice(0, 1).pop();\n\n    utxoSelection.selection.push(utxo);\n    utxoSelection.amount = addAmounts(\n      utxo.output().amount(),\n      utxoSelection.amount\n    );\n\n    limit--;\n  } while (\n    !isQtyFulfilled(\n      outputAmount,\n      utxoSelection.amount,\n      minUTxOValue,\n      utxoSelection.subset.length - 1\n    )\n  );\n\n  // Quantity is met, return subset into remaining list and return selection\n  utxoSelection.remaining = [\n    ...utxoSelection.remaining,\n    ...utxoSelection.subset,\n  ];\n  utxoSelection.subset = [];\n\n  return utxoSelection;\n}\n\n/**\n * Try to improve selection by increasing input amount in [2x,3x] range.\n * @param {UTxOSelection} utxoSelection - The set of selected/available inputs.\n * @param {Value} outputAmount - Single compiled output qty requested for payment.\n * @param {int} limit - A limit on the number of inputs that can be selected.\n * @param {ImproveRange} range - Improvement range target values\n */\nfunction improve(utxoSelection, outputAmount, limit, range) {\n  let nbFreeUTxO = utxoSelection.subset.length;\n\n  if (\n    compare(utxoSelection.amount, range.ideal) >= 0 ||\n    nbFreeUTxO <= 0 ||\n    limit <= 0\n  ) {\n    // Return subset in remaining\n    utxoSelection.remaining = [\n      ...utxoSelection.remaining,\n      ...utxoSelection.subset,\n    ];\n    utxoSelection.subset = [];\n\n    return;\n  }\n\n  /** @type {TransactionUnspentOutput} utxo */\n  const utxo = utxoSelection.subset\n    .splice(Math.floor(Math.random() * nbFreeUTxO), 1)\n    .pop();\n\n  const newAmount = Loader.Cardano.Value.new(\n    Loader.Cardano.BigNum.from_str(\"0\")\n  )\n    .checked_add(utxo.output().amount())\n    .checked_add(outputAmount);\n\n  if (\n    abs(getAmountValue(range.ideal) - getAmountValue(newAmount)) <\n      abs(getAmountValue(range.ideal) - getAmountValue(outputAmount)) &&\n    compare(newAmount, range.maximum) <= 0\n  ) {\n    utxoSelection.selection.push(utxo);\n    utxoSelection.amount = addAmounts(\n      utxo.output().amount(),\n      utxoSelection.amount\n    );\n    limit--;\n  } else {\n    utxoSelection.remaining.push(utxo);\n  }\n\n  return improve(utxoSelection, outputAmount, limit, range);\n}\n\n/**\n * Compile all required outputs to a flat amounts list\n * @param {TransactionOutputs} outputs - The set of outputs requested for payment.\n * @return {Value} - The compiled set of amounts requested for payment.\n */\nfunction mergeOutputsAmounts(outputs) {\n  let compiledAmountList = Loader.Cardano.Value.new(\n    Loader.Cardano.BigNum.from_str(\"0\")\n  );\n\n  for (let i = 0; i < outputs.len(); i++) {\n    compiledAmountList = addAmounts(\n      outputs.get(i).amount(),\n      compiledAmountList\n    );\n  }\n\n  return compiledAmountList;\n}\n\n/**\n * Add up an Amounts List values to another Amounts List\n * @param {Value} amounts - Set of amounts to be added.\n * @param {Value} compiledAmounts - The compiled set of amounts.\n * @return {Value}\n */\nfunction addAmounts(amounts, compiledAmounts) {\n  return compiledAmounts.checked_add(amounts);\n}\n\n/**\n * Split amounts contained in a single {Value} object in separate {Value} objects\n * @param {Value} amounts - Set of amounts to be split.\n * @throws MIN_UTXO_ERROR if lovelace change is under 'minUTxOValue' parameter.\n * @return {AmountList}\n */\nfunction splitAmounts(amounts) {\n  let splitAmounts = [];\n\n  if (amounts.multiasset()) {\n    let mA = amounts.multiasset();\n\n    for (let i = 0; i < mA.keys().len(); i++) {\n      let scriptHash = mA.keys().get(i);\n\n      for (let j = 0; j < mA.get(scriptHash).keys().len(); j++) {\n        let _assets = Loader.Cardano.Assets.new();\n        let assetName = mA.get(scriptHash).keys().get(j);\n\n        _assets.insert(\n          Loader.Cardano.AssetName.from_bytes(assetName.to_bytes()),\n          Loader.Cardano.BigNum.from_bytes(\n            mA.get(scriptHash).get(assetName).to_bytes()\n          )\n        );\n\n        let _multiasset = Loader.Cardano.MultiAsset.new();\n        _multiasset.insert(\n          Loader.Cardano.ScriptHash.from_bytes(scriptHash.to_bytes()),\n          _assets\n        );\n        let _value = Loader.Cardano.Value.new(\n          Loader.Cardano.BigNum.from_str(\"0\")\n        );\n        _value.set_multiasset(_multiasset);\n\n        splitAmounts.push(_value);\n      }\n    }\n  }\n\n  // Order assets by qty DESC\n  splitAmounts = sortAmountList(splitAmounts, \"DESC\");\n\n  // Insure lovelace is last to account for min ada requirement\n  splitAmounts.push(\n    Loader.Cardano.Value.new(\n      Loader.Cardano.BigNum.from_bytes(amounts.coin().to_bytes())\n    )\n  );\n\n  return splitAmounts;\n}\n\n/**\n * Sort a mismatched AmountList ASC/DESC\n * @param {AmountList} amountList - Set of mismatched amounts to be sorted.\n * @param {string} [sortOrder=ASC] - Order\n * @return {AmountList} - The sorted AmountList\n */\nfunction sortAmountList(amountList, sortOrder = \"ASC\") {\n  return amountList.sort((a, b) => {\n    let sortInt = sortOrder === \"DESC\" ? BigInt(-1) : BigInt(1);\n    return Number((getAmountValue(a) - getAmountValue(b)) * sortInt);\n  });\n}\n\n/**\n * Return BigInt amount value\n * @param {Value} amount\n * @return {bigint}\n */\nfunction getAmountValue(amount) {\n  let val = BigInt(0);\n  let lovelace = BigInt(amount.coin().to_str());\n\n  if (lovelace > 0) {\n    val = lovelace;\n  } else if (amount.multiasset() && amount.multiasset().len() > 0) {\n    let scriptHash = amount.multiasset().keys().get(0);\n    let assetName = amount.multiasset().get(scriptHash).keys().get(0);\n    val = BigInt(amount.multiasset().get(scriptHash).get(assetName).to_str());\n  }\n\n  return val;\n}\n\n/**\n * Search & Return BigInt amount value\n * @param {Value} needle\n * @param {Value} haystack\n * @return {bigint}\n */\nfunction searchAmountValue(needle, haystack) {\n  let val = BigInt(0);\n  let lovelace = BigInt(needle.coin().to_str());\n\n  if (lovelace > 0) {\n    val = BigInt(haystack.coin().to_str());\n  } else if (\n    needle.multiasset() &&\n    haystack.multiasset() &&\n    needle.multiasset().len() > 0 &&\n    haystack.multiasset().len() > 0\n  ) {\n    let scriptHash = needle.multiasset().keys().get(0);\n    let assetName = needle.multiasset().get(scriptHash).keys().get(0);\n    val = BigInt(haystack.multiasset().get(scriptHash).get(assetName).to_str());\n  }\n\n  return val;\n}\n\n/**\n * Narrow down remaining UTxO set in case of native token, use full set for lovelace\n * @param {UTxOSelection} utxoSelection - The set of selected/available inputs.\n * @param {Value} output - Single compiled output qty requested for payment.\n */\nfunction createSubSet(utxoSelection, output) {\n  if (BigInt(output.coin().to_str()) < BigInt(1)) {\n    let subset = [];\n    let remaining = [];\n    for (let i = 0; i < utxoSelection.remaining.length; i++) {\n      if (\n        compare(utxoSelection.remaining[i].output().amount(), output) !==\n        undefined\n      ) {\n        subset.push(utxoSelection.remaining[i]);\n      } else {\n        remaining.push(utxoSelection.remaining[i]);\n      }\n    }\n    utxoSelection.subset = subset;\n    utxoSelection.remaining = remaining;\n  } else {\n    utxoSelection.subset = utxoSelection.remaining.splice(\n      0,\n      utxoSelection.remaining.length\n    );\n  }\n}\n\n/**\n * Is Quantity Fulfilled Condition - Handle 'minUTxOValue' protocol parameter.\n * @param {Value} outputAmount - Single compiled output qty requested for payment.\n * @param {Value} cumulatedAmount - Single compiled accumulated UTxO qty.\n * @param {int} minUTxOValue - Network protocol 'minUTxOValue' current value.\n * @param {int} nbFreeUTxO - Number of free UTxO available.\n * @return {boolean}\n */\nfunction isQtyFulfilled(\n  outputAmount,\n  cumulatedAmount,\n  minUTxOValue,\n  nbFreeUTxO\n) {\n  let amount = outputAmount;\n\n  if (minUTxOValue && BigInt(outputAmount.coin().to_str()) > 0) {\n    let minAmount = Loader.Cardano.Value.new(\n      Loader.Cardano.min_ada_required(\n        cumulatedAmount,\n        Loader.Cardano.BigNum.from_str(minUTxOValue.toString())\n      )\n    );\n\n    // Lovelace min amount to cover assets and number of output need to be met\n    if (compare(cumulatedAmount, minAmount) < 0) return false;\n\n    // If requested Lovelace lower than minAmount, plan for change\n    if (compare(outputAmount, minAmount) < 0) {\n      amount = minAmount.checked_add(\n        Loader.Cardano.Value.new(\n          Loader.Cardano.BigNum.from_str(protocolParameters.minUTxO)\n        )\n      );\n    }\n\n    // Try covering the max fees\n    if (nbFreeUTxO > 0) {\n      let maxFee =\n        BigInt(protocolParameters.minFeeA) *\n          BigInt(protocolParameters.maxTxSize) +\n        BigInt(protocolParameters.minFeeB);\n\n      maxFee = Loader.Cardano.Value.new(\n        Loader.Cardano.BigNum.from_str(maxFee.toString())\n      );\n\n      amount = amount.checked_add(maxFee);\n    }\n  }\n\n  return compare(cumulatedAmount, amount) >= 0;\n}\n\n/**\n * Return a deep copy of UTxOSelection\n * @param {UTxOSelection} utxoSelection\n * @return {UTxOSelection} Clone - Deep copy\n */\nfunction cloneUTxOSelection(utxoSelection) {\n  return {\n    selection: cloneUTxOList(utxoSelection.selection),\n    remaining: cloneUTxOList(utxoSelection.remaining),\n    subset: cloneUTxOList(utxoSelection.subset),\n    amount: cloneValue(utxoSelection.amount),\n  };\n}\n\n/**\n * Return a deep copy of an UTxO List\n * @param {UTxOList} utxoList\n * @return {UTxOList} Cone - Deep copy\n */\nconst cloneUTxOList = (utxoList) =>\n  utxoList.map((utxo) =>\n    Loader.Cardano.TransactionUnspentOutput.from_bytes(utxo.to_bytes())\n  );\n\n/**\n * Return a deep copy of a Value object\n * @param {Value} value\n * @return {Value} Cone - Deep copy\n */\nconst cloneValue = (value) => Loader.Cardano.Value.from_bytes(value.to_bytes());\n\n// Helper\nfunction abs(big) {\n  return big < 0 ? big * BigInt(-1) : big;\n}\n\n/**\n * Compare a candidate value to the one in a group if present\n * @param {Value} group\n * @param {Value} candidate\n * @return {int} - -1 group lower, 0 equal, 1 group higher, undefined if no match\n */\nfunction compare(group, candidate) {\n  let gQty = BigInt(group.coin().to_str());\n  let cQty = BigInt(candidate.coin().to_str());\n\n  if (candidate.multiasset()) {\n    let cScriptHash = candidate.multiasset().keys().get(0);\n    let cAssetName = candidate.multiasset().get(cScriptHash).keys().get(0);\n\n    if (group.multiasset() && group.multiasset().len()) {\n      if (\n        group.multiasset().get(cScriptHash) &&\n        group.multiasset().get(cScriptHash).get(cAssetName)\n      ) {\n        gQty = BigInt(\n          group.multiasset().get(cScriptHash).get(cAssetName).to_str()\n        );\n        cQty = BigInt(\n          candidate.multiasset().get(cScriptHash).get(cAssetName).to_str()\n        );\n      } else {\n        return undefined;\n      }\n    } else {\n      return undefined;\n    }\n  }\n\n  return gQty >= cQty ? (gQty === cQty ? 0 : 1) : -1;\n}\n\nexport default CoinSelection;\n","import { withPrefix } from \"gatsby\";\nimport * as React from \"react\";\nimport Market from \"../cardano/market\";\nimport * as secrets from \"../../secrets\";\n//import { createField, createForm } from \"mobx-easy-form\";\n//import { Observer, observer } from \"mobx-react\";\n//import { useMemo } from \"react\";\n//import * as yup from \"yup\";\n\n\n// styles\nconst pageStyles = {\n  color: \"#232129\",\n  padding: 96,\n  fontFamily: \"-apple-system, Roboto, sans-serif, serif\",\n}\nconst headingStyles = {\n  marginTop: 0,\n  marginBottom: 64,\n  maxWidth: 320,\n}\nconst headingAccentStyles = {\n  color: \"#663399\",\n}\nconst paragraphStyles = {\n  marginBottom: 48,\n}\nconst codeStyles = {\n  color: \"#8A6534\",\n  padding: 4,\n  backgroundColor: \"#FFF4DB\",\n  fontSize: \"1.25rem\",\n  borderRadius: 4,\n}\nconst listStyles = {\n  marginBottom: 96,\n  paddingLeft: 0,\n}\nconst listItemStyles = {\n  fontWeight: 300,\n  fontSize: 24,\n  maxWidth: 560,\n  marginBottom: 30,\n}\n\nconst linkStyle = {\n  color: \"#8954A8\",\n  fontWeight: \"bold\",\n  fontSize: 16,\n  verticalAlign: \"5%\",\n}\n\nconst docLinkStyle = {\n  ...linkStyle,\n  listStyleType: \"none\",\n  marginBottom: 24,\n}\n\nconst descriptionStyle = {\n  color: \"#232129\",\n  fontSize: 14,\n  marginTop: 10,\n  marginBottom: 0,\n  lineHeight: 1.25,\n}\n\nconst docLink = {\n  text: \"Documentation\",\n  url: \"https://www.gatsbyjs.com/docs/\",\n  color: \"#8954A8\",\n}\n\nconst badgeStyle = {\n  color: \"#fff\",\n  backgroundColor: \"#088413\",\n  border: \"1px solid #088413\",\n  fontSize: 11,\n  fontWeight: \"bold\",\n  letterSpacing: 1,\n  borderRadius: 4,\n  padding: \"4px 6px\",\n  display: \"inline-block\",\n  position: \"relative\",\n  top: -2,\n  marginLeft: 10,\n  lineHeight: 1,\n}\n\n// data\nconst links = [\n  {\n    text: \"Tutorial\",\n    url: \"https://www.gatsbyjs.com/docs/tutorial/\",\n    description:\n      \"A great place to get started if you're new to web development. Designed to guide you through setting up your first Gatsby site.\",\n    color: \"#E95800\",\n  },\n  {\n    text: \"How to Guides\",\n    url: \"https://www.gatsbyjs.com/docs/how-to/\",\n    description:\n      \"Practical step-by-step guides to help you achieve a specific goal. Most useful when you're trying to get something done.\",\n    color: \"#1099A8\",\n  },\n  {\n    text: \"Reference Guides\",\n    url: \"https://www.gatsbyjs.com/docs/reference/\",\n    description:\n      \"Nitty-gritty technical descriptions of how Gatsby works. Most useful when you need detailed information about Gatsby's APIs.\",\n    color: \"#BC027F\",\n  },\n  {\n    text: \"Conceptual Guides\",\n    url: \"https://www.gatsbyjs.com/docs/conceptual/\",\n    description:\n      \"Big-picture explanations of higher-level Gatsby concepts. Most useful for building understanding of a particular topic.\",\n    color: \"#0D96F2\",\n  },\n  {\n    text: \"Plugin Library\",\n    url: \"https://www.gatsbyjs.com/plugins\",\n    description:\n      \"Add functionality and customize your Gatsby site or app with thousands of plugins built by our amazing developer community.\",\n    color: \"#8EB814\",\n  },\n  {\n    text: \"Build and Host\",\n    url: \"https://www.gatsbyjs.com/cloud\",\n    badge: true,\n    description:\n      \"Now you’re ready to show the world! Give your Gatsby site superpowers: Build and host on Gatsby Cloud. Get started for free!\",\n    color: \"#663399\",\n  },\n]\n\n/*const loadMarket = async () => {\n  market.current = new Market(\n    {\n      base: \"https://cardano-mainnet.blockfrost.io/api/v0\",\n      projectId: secrets.PROJECT_ID\n    }\n  );\n  await market.current.load();\n  loadSpaceBudData();\n};\n\nconst form = createForm({\n  async onSubmit({ values }) {\n    console.log(values);\n  },\n});\n\nconst firstName = createField({\n  id: \"firstName\",\n  form,\n  initialValue: \"\",\n});*/\n\n// markup\nconst IndexPage = () => {\n  return (\n    <main style={pageStyles}>\n      <title>Home Page</title>\n      <h1 style={headingStyles}>\n        Congratulations\n        <br />\n        <span style={headingAccentStyles}>— you just made a Gatsby site! </span>\n        <span role=\"img\" aria-label=\"Party popper emojis\">\n          🎉🎉🎉\n        </span>\n      </h1>\n      <p style={paragraphStyles}>\n        Edit <code style={codeStyles}>src/pages/index.js</code> to see this page\n        update in real-time.{\" \"}\n        <span role=\"img\" aria-label=\"Sunglasses smiley emoji\">\n          😎\n        </span>\n      </p>\n      <ul style={listStyles}>\n        <li style={docLinkStyle}>\n          <a\n            style={linkStyle}\n            href={`${docLink.url}?utm_source=starter&utm_medium=start-page&utm_campaign=minimal-starter`}\n          >\n            {docLink.text}\n          </a>\n        </li>\n        {links.map(link => (\n          <li key={link.url} style={{ ...listItemStyles, color: link.color }}>\n            <span>\n              <a\n                style={linkStyle}\n                href={`${link.url}?utm_source=starter&utm_medium=start-page&utm_campaign=minimal-starter`}\n              >\n                {link.text}\n              </a>\n              {link.badge && (\n                <span style={badgeStyle} aria-label=\"New Badge\">\n                  NEW!\n                </span>\n              )}\n              <p style={descriptionStyle}>{link.description}</p>\n            </span>\n          </li>\n        ))}\n      </ul>\n      <img\n        alt=\"Gatsby G Logo\"\n        src=\"data:image/svg+xml,%3Csvg width='24' height='24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M12 2a10 10 0 110 20 10 10 0 010-20zm0 2c-3.73 0-6.86 2.55-7.75 6L14 19.75c3.45-.89 6-4.02 6-7.75h-5.25v1.5h3.45a6.37 6.37 0 01-3.89 4.44L6.06 9.69C7 7.31 9.3 5.63 12 5.63c2.13 0 4 1.04 5.18 2.65l1.23-1.06A7.959 7.959 0 0012 4zm-8 8a8 8 0 008 8c.04 0 .09 0-8-8z' fill='%23639'/%3E%3C/svg%3E\"\n      />\n    </main>\n  )\n}\n\nexport default IndexPage\n"],"names":["secrets","PROJECT_ID","Loader","load","this","_wasm","window","BigInt","pageStyles","color","padding","fontFamily","headingStyles","marginTop","marginBottom","maxWidth","headingAccentStyles","paragraphStyles","codeStyles","backgroundColor","fontSize","borderRadius","listStyles","paddingLeft","listItemStyles","fontWeight","linkStyle","verticalAlign","docLinkStyle","listStyleType","descriptionStyle","lineHeight","docLink","badgeStyle","border","letterSpacing","display","position","top","marginLeft","links","text","url","description","badge","style","role","href","map","link","key","alt","src"],"sourceRoot":""}